4f735bc6e72691152b3a87dd7d29bb394be5c785
Update lowrisc_ibex to lowRISC/ibex@dd39ec0
diff --git a/hw/vendor/lowrisc_ibex/rtl/ibex_alu.sv b/hw/vendor/lowrisc_ibex/rtl/ibex_alu.sv
index 6744ac4e0..de0e59f5b 100644
--- a/hw/vendor/lowrisc_ibex/rtl/ibex_alu.sv
+++ b/hw/vendor/lowrisc_ibex/rtl/ibex_alu.sv
@@ -89,6 +89,70 @@ module ibex_alu #(
 
   assign adder_result_o     = adder_result;
 
+  ////////////////
+  // Comparison //
+  ////////////////
+
+  logic is_equal;
+  logic is_greater_equal;  // handles both signed and unsigned forms
+  logic cmp_signed;
+
+  always_comb begin
+    unique case (operator_i)
+      ALU_GE,
+      ALU_LT,
+      ALU_SLT,
+      // RV32B only
+      ALU_MIN,
+      ALU_MAX: cmp_signed = 1'b1;
+
+      default: cmp_signed = 1'b0;
+    endcase
+  end
+
+  assign is_equal = (adder_result == 32'b0);
+  assign is_equal_result_o = is_equal;
+
+  // Is greater equal
+  always_comb begin
+    if ((operand_a_i[31] ^ operand_b_i[31]) == 1'b0) begin
+      is_greater_equal = (adder_result[31] == 1'b0);
+    end else begin
+      is_greater_equal = operand_a_i[31] ^ (cmp_signed);
+    end
+  end
+
+  // GTE unsigned:
+  // (a[31] == 1 && b[31] == 1) => adder_result[31] == 0
+  // (a[31] == 0 && b[31] == 0) => adder_result[31] == 0
+  // (a[31] == 1 && b[31] == 0) => 1
+  // (a[31] == 0 && b[31] == 1) => 0
+
+  // GTE signed:
+  // (a[31] == 1 && b[31] == 1) => adder_result[31] == 0
+  // (a[31] == 0 && b[31] == 0) => adder_result[31] == 0
+  // (a[31] == 1 && b[31] == 0) => 0
+  // (a[31] == 0 && b[31] == 1) => 1
+
+  // generate comparison result
+  logic cmp_result;
+
+  always_comb begin
+    unique case (operator_i)
+      ALU_EQ:             cmp_result =  is_equal;
+      ALU_NE:             cmp_result = ~is_equal;
+      ALU_GE,   ALU_GEU,
+      ALU_MAX,  ALU_MAXU: cmp_result = is_greater_equal; // RV32B only
+      ALU_LT,   ALU_LTU,
+      ALU_MIN,  ALU_MINU, //RV32B only
+      ALU_SLT,  ALU_SLTU: cmp_result = ~is_greater_equal;
+
+      default: cmp_result = is_equal;
+    endcase
+  end
+
+  assign comparison_result_o = cmp_result;
+
   ///////////
   // Shift //
   ///////////
@@ -96,7 +160,7 @@ module ibex_alu #(
   // The shifter structure consists of a 33-bit shifter: 32-bit operand + 1 bit extension for
   // arithmetic shifts and one-shift support.
   // Rotations and funnel shifts are implemented as multi-cycle instructions.
-  // The shifter is also used for single-bit instructions as detailed below.
+  // The shifter is also used for single-bit instructions and bit-field place as detailed below.
   //
   // Standard Shifts
   // ===============
@@ -152,12 +216,9 @@ module ibex_alu #(
   // For sbext, the bit defined by operand_b_i[4:0] is to be returned. This is done by simply
   // shifting operand_a_i to the right by the required amount and returning bit [0] of the result.
   //
-  // Generalized Reverse and Or-Combine
-  // ==================================
-  // Grev and gorc instructions share the reversing structure used for left-shifts. The control
-  // bits are the same for shifts and grev/gorc. Shift_amt can therefore be reused for activating
-  // the respective reversal stages.
-
+  // Bit-Field Place
+  // ===============
+  // The shifter structure is shared to compute bfp_mask << bfp_off.
 
   logic       shift_left;
   logic       shift_ones;
@@ -167,19 +228,49 @@ module ibex_alu #(
   logic [5:0] shift_amt;
   logic [5:0] shift_amt_compl; // complementary shift amount (32 - shift_amt)
 
+  logic [31:0] shift_result;
+  logic [32:0] shift_result_ext;
+  logic [31:0] shift_result_rev;
+
+  // zbf
+  logic bfp_op;
+  logic [4:0]  bfp_len;
+  logic [4:0]  bfp_off;
+  logic [31:0] bfp_mask;
+  logic [31:0] bfp_mask_rev;
+  logic [31:0] bfp_result;
+
+  // bfp: shares the shifter structure to compute bfp_mask << bfp_off
+  assign bfp_op = RV32B ? (operator_i == ALU_BFP) : 1'b0;
+  assign bfp_len = {~(|operand_b_i[27:24]), operand_b_i[27:24]}; // len = 0 encodes for len = 16
+  assign bfp_off = operand_b_i[20:16];
+  assign bfp_mask = RV32B ? ~(32'hffff_ffff << bfp_len) : '0;
+  for (genvar i=0; i<32; i++) begin : gen_rev_bfp_mask
+    assign bfp_mask_rev[i] = bfp_mask[31-i];
+  end
+
+  assign bfp_result =
+      RV32B ? (~shift_result & operand_a_i) | ((operand_b_i & bfp_mask) << bfp_off) : '0;
+
   // bit shift_amt[5]: word swap bit: only considered for FSL/FSR.
   // if set, reverse operations in first and second cycle.
-  assign shift_amt[5] = operand_b_i[5] && shift_funnel;
+  assign shift_amt[5] = operand_b_i[5] & shift_funnel;
   assign shift_amt_compl = 32 - operand_b_i[4:0];
 
-  assign shift_amt[4:0] = instr_first_cycle_i ?
-      (operand_b_i[5] && shift_funnel ? shift_amt_compl[4:0] : operand_b_i[4:0]) :
-      (operand_b_i[5] && shift_funnel ? operand_b_i[4:0] : shift_amt_compl[4:0]);
+  always_comb begin
+    if (bfp_op) begin
+      shift_amt[4:0] = bfp_off ; // length field of bfp control word
+    end else begin
+      shift_amt[4:0] = instr_first_cycle_i ?
+          (operand_b_i[5] && shift_funnel ? shift_amt_compl[4:0] : operand_b_i[4:0]) :
+          (operand_b_i[5] && shift_funnel ? operand_b_i[4:0] : shift_amt_compl[4:0]);
+    end
+  end
+
 
   // single-bit mode: shift
-  assign shift_sbmode = RV32B ? (operator_i == ALU_SBSET) || (operator_i == ALU_SBCLR) ||
-                                    (operator_i == ALU_SBINV) :
-                                1'b0;
+  assign shift_sbmode = RV32B ?
+      (operator_i == ALU_SBSET) | (operator_i == ALU_SBCLR) | (operator_i == ALU_SBINV) : 1'b0;
 
   // left shift if this is:
   // * a standard left shift (slo, sll)
@@ -188,16 +279,18 @@ module ibex_alu #(
   // * fsl: without word-swap bit: first cycle, else: second cycle
   // * fsr: without word-swap bit: second cycle, else: first cycle
   // * a single-bit instruction: sbclr, sbset, sbinv (excluding sbext)
+  // * bfp: bfp_mask << bfp_off
   always_comb begin
     unique case (operator_i)
       ALU_SLL: shift_left = 1'b1;
-      ALU_SLO: shift_left = RV32B ? 1'b1 : 1'b0;
+      ALU_SLO,
+      ALU_BFP: shift_left = RV32B ? 1'b1 : 1'b0;
       ALU_ROL: shift_left = RV32B ? instr_first_cycle_i : 0;
-      ALU_ROR: shift_left = RV32B ? !instr_first_cycle_i : 0;
+      ALU_ROR: shift_left = RV32B ? ~instr_first_cycle_i : 0;
       ALU_FSL: shift_left =
-          RV32B ? (shift_amt[5] ? !instr_first_cycle_i : instr_first_cycle_i) : 1'b0;
+          RV32B ? (shift_amt[5] ? ~instr_first_cycle_i : instr_first_cycle_i) : 1'b0;
       ALU_FSR: shift_left =
-          RV32B ? (shift_amt[5] ? instr_first_cycle_i : !instr_first_cycle_i) : 1'b0;
+          RV32B ? (shift_amt[5] ? instr_first_cycle_i : ~instr_first_cycle_i) : 1'b0;
       default: shift_left = 1'b0;
     endcase
     if (shift_sbmode) begin
@@ -206,146 +299,38 @@ module ibex_alu #(
   end
 
   assign shift_arith      = (operator_i == ALU_SRA);
-  assign shift_ones       = RV32B ? (operator_i == ALU_SLO) || (operator_i == ALU_SRO) : 1'b0;
-  assign shift_funnel     = RV32B ? (operator_i == ALU_FSL) || (operator_i == ALU_FSR) : 1'b0;
-
-  logic [31:0] shift_result;
-  logic [32:0] shift_result_ext;
-
-  // grev / gorc instructions
-  logic grev_op;
-  assign grev_op = RV32B ? (operator_i == ALU_GREV) : 1'b0;
-  logic gorc_op;
-  assign gorc_op = RV32B ? (operator_i == ALU_GORC) : 1'b0;
+  assign shift_ones       = RV32B ? (operator_i == ALU_SLO) | (operator_i == ALU_SRO) : 1'b0;
+  assign shift_funnel     = RV32B ? (operator_i == ALU_FSL) | (operator_i == ALU_FSR) : 1'b0;
 
-  // combined shifter/ reverser structure.
+  // shifter structure.
   always_comb begin
-    shift_result = operand_a_i;
 
-    // select bit reversed or normal input
-    if (shift_left) begin
-      shift_result = operand_a_rev;
-    end
-
-    // if this is a single bit instruction: we left-shift 32'h1 by shift_amt.
-    // the first reverse of the left-shift operation can be easily omitted, since we
-    // know the result of rev(32'h1).
+    // select shifter input
+    // for bfp, sbmode and shift_left the corresponding bit-reversed input is chosen.
     if (shift_sbmode) begin
-      shift_result = 32'h8000_0000;
+      shift_result = 32'h8000_0000; // rev(32'h1)
+    end else begin
+      unique case (1'b1)
+        bfp_op:       shift_result = bfp_mask_rev;
+        shift_left:   shift_result = operand_a_rev;
+        default:      shift_result = operand_a_i;
+      endcase
     end
 
-    shift_result_ext = $signed({shift_ones || (shift_arith && shift_result[31]), shift_result})
-        >>> shift_amt[4:0];
 
-    shift_result = shift_result_ext[31:0];
-
-    if (grev_op || gorc_op) begin
-      shift_result = operand_a_i;
-    end
-
-    // left shift always do the full reverse. Orc and rev do permutation as requested by shift_amt.
-    if (shift_left || ((grev_op || gorc_op) & shift_amt[0])) begin
-      shift_result = (gorc_op ? shift_result : 32'h0)       |
-                      ((shift_result & 32'h5555_5555) <<  1)|
-                      ((shift_result & 32'haaaa_aaaa) >>  1);
-    end
+    shift_result_ext =
+        $signed({shift_ones | (shift_arith & shift_result[31]), shift_result}) >>> shift_amt[4:0];
 
-    if (shift_left || ((grev_op || gorc_op) & shift_amt[1])) begin
-      shift_result = (gorc_op ? shift_result : 32'h0)       |
-                      ((shift_result & 32'h3333_3333) <<  2)|
-                      ((shift_result & 32'hcccc_cccc) >>  2);
-    end
+    shift_result = shift_result_ext[31:0];
 
-    if (shift_left || ((grev_op || gorc_op) & shift_amt[2])) begin
-      shift_result = (gorc_op ? shift_result : 32'h0)       |
-                      ((shift_result & 32'h0f0f_0f0f) <<  4)|
-                      ((shift_result & 32'hf0f0_f0f0) >>  4);
+    for (int unsigned i=0; i<32; i++) begin
+      shift_result_rev[i] = shift_result[31-i];
     end
 
-    if (shift_left || ((grev_op || gorc_op) & shift_amt[3])) begin
-      shift_result = (gorc_op ? shift_result : 32'h0)       |
-                     ((shift_result & 32'h00ff_00ff) <<  8) |
-                     ((shift_result & 32'hff00_ff00) >>  8);
-    end
+    shift_result = shift_left ? shift_result_rev : shift_result;
 
-    if (shift_left || ((grev_op || gorc_op) & shift_amt[4])) begin
-      shift_result = (gorc_op ? shift_result : 32'h0)       |
-                     ((shift_result & 32'h0000_ffff) << 16) |
-                     ((shift_result & 32'hffff_0000) >> 16);
-    end
   end
 
-  ////////////////
-  // Comparison //
-  ////////////////
-
-  logic is_equal;
-  logic is_greater_equal;  // handles both signed and unsigned forms
-  logic cmp_signed;
-
-  always_comb begin
-    unique case (operator_i)
-      ALU_GE,
-      ALU_LT,
-      ALU_SLT,
-      // RV32B only
-      ALU_MIN,
-      ALU_MAX: cmp_signed = 1'b1;
-
-      default: cmp_signed = 1'b0;
-    endcase
-  end
-
-  assign is_equal = (adder_result == 32'b0);
-  assign is_equal_result_o = is_equal;
-
-  // Is greater equal
-  always_comb begin
-    if ((operand_a_i[31] ^ operand_b_i[31]) == 1'b0) begin
-      is_greater_equal = (adder_result[31] == 1'b0);
-    end else begin
-      is_greater_equal = operand_a_i[31] ^ (cmp_signed);
-    end
-  end
-
-  // GTE unsigned:
-  // (a[31] == 1 && b[31] == 1) => adder_result[31] == 0
-  // (a[31] == 0 && b[31] == 0) => adder_result[31] == 0
-  // (a[31] == 1 && b[31] == 0) => 1
-  // (a[31] == 0 && b[31] == 1) => 0
-
-  // GTE signed:
-  // (a[31] == 1 && b[31] == 1) => adder_result[31] == 0
-  // (a[31] == 0 && b[31] == 0) => adder_result[31] == 0
-  // (a[31] == 1 && b[31] == 0) => 0
-  // (a[31] == 0 && b[31] == 1) => 1
-
-  // generate comparison result
-  logic cmp_result;
-
-  always_comb begin
-    unique case (operator_i)
-      ALU_EQ:             cmp_result =  is_equal;
-      ALU_NE:             cmp_result = ~is_equal;
-      ALU_GE,   ALU_GEU,
-      ALU_MAX,  ALU_MAXU: cmp_result = is_greater_equal; // RV32B only
-      ALU_LT,   ALU_LTU,
-      ALU_MIN,  ALU_MINU, //RV32B only
-      ALU_SLT,  ALU_SLTU: cmp_result = ~is_greater_equal;
-
-      default: cmp_result = is_equal;
-    endcase
-  end
-
-  assign comparison_result_o = cmp_result;
-
-  logic [31:0] minmax_result;
-  logic [5:0]  bitcnt_result;
-  logic [31:0] bwlogic_result;
-  logic [31:0] pack_result;
-  logic [31:0] multicycle_result;
-  logic [31:0] singlebit_result;
-
   ///////////////////
   // Bitwise Logic //
   ///////////////////
@@ -356,6 +341,7 @@ module ibex_alu #(
   logic [31:0] bwlogic_or_result;
   logic [31:0] bwlogic_and_result;
   logic [31:0] bwlogic_xor_result;
+  logic [31:0] bwlogic_result;
 
   logic bwlogic_op_b_negate;
 
@@ -365,7 +351,7 @@ module ibex_alu #(
       ALU_XNOR,
       ALU_ORN,
       ALU_ANDN: bwlogic_op_b_negate = RV32B ? 1'b1 : 1'b0;
-      ALU_CMIX: bwlogic_op_b_negate = RV32B ? !instr_first_cycle_i : 1'b0;
+      ALU_CMIX: bwlogic_op_b_negate = RV32B ? ~instr_first_cycle_i : 1'b0;
       default:  bwlogic_op_b_negate = 1'b0;
     endcase
   end
@@ -376,8 +362,8 @@ module ibex_alu #(
   assign bwlogic_and_result = operand_a_i & bwlogic_operand_b;
   assign bwlogic_xor_result = operand_a_i ^ bwlogic_operand_b;
 
-  assign bwlogic_or  = (operator_i == ALU_OR) || (operator_i == ALU_ORN);
-  assign bwlogic_and = (operator_i == ALU_AND) || (operator_i == ALU_ANDN);
+  assign bwlogic_or  = (operator_i == ALU_OR)  | (operator_i == ALU_ORN);
+  assign bwlogic_and = (operator_i == ALU_AND) | (operator_i == ALU_ANDN);
 
   always_comb begin
     unique case (1'b1)
@@ -388,9 +374,336 @@ module ibex_alu #(
   end
 
   logic [31:0] shuffle_result;
+  logic [31:0] butterfly_result;
+  logic [31:0] invbutterfly_result;
+
+  logic [31:0] minmax_result;
+  logic [5:0]  bitcnt_result;
+  logic [31:0] pack_result;
+  logic [31:0] sext_result;
+  logic [31:0] multicycle_result;
+  logic [31:0] singlebit_result;
+  logic [31:0] clmul_result;
 
   if (RV32B) begin : g_alu_rvb
 
+    /////////////////
+    // Bitcounting //
+    /////////////////
+
+    // The bit-counter structure computes the number of set bits in its operand. Partial results
+    // (from left to right) are needed to compute the control masks for computation of bext/bdep
+    // by the butterfly network, if implemented.
+    // For pcnt, clz and ctz, only the end result is used.
+
+    logic        zbe_op;
+    logic        bitcnt_ctz;
+    logic        bitcnt_clz;
+    logic        bitcnt_cz;
+    logic [31:0] bitcnt_bits;
+    logic [31:0] bitcnt_mask_op;
+    logic [31:0] bitcnt_bit_mask;
+    logic [ 5:0] bitcnt_partial [32];
+
+
+    assign bitcnt_ctz    = operator_i == ALU_CTZ;
+    assign bitcnt_clz    = operator_i == ALU_CLZ;
+    assign bitcnt_cz     = bitcnt_ctz | bitcnt_clz;
+    assign bitcnt_result = bitcnt_partial[31];
+
+    // Bit-mask generation for clz and ctz:
+    // The bit mask is generated by spreading the lowest-order set bit in the operand to all
+    // higher order bits. The resulting mask is inverted to cover the lowest order zeros. In order
+    // to create the bit mask for leading zeros, the input operand needs to be reversed.
+    assign bitcnt_mask_op = bitcnt_clz ? operand_a_rev : operand_a_i;
+
+    always_comb begin
+      bitcnt_bit_mask = bitcnt_mask_op;
+      bitcnt_bit_mask |= bitcnt_bit_mask << 1;
+      bitcnt_bit_mask |= bitcnt_bit_mask << 2;
+      bitcnt_bit_mask |= bitcnt_bit_mask << 4;
+      bitcnt_bit_mask |= bitcnt_bit_mask << 8;
+      bitcnt_bit_mask |= bitcnt_bit_mask << 16;
+      bitcnt_bit_mask = ~bitcnt_bit_mask;
+    end
+
+    always_comb begin
+      case(1'b1)
+        zbe_op:      bitcnt_bits = operand_b_i;
+        bitcnt_cz:   bitcnt_bits = bitcnt_bit_mask & ~bitcnt_mask_op; // clz / ctz
+        default:     bitcnt_bits = operand_a_i; // pcnt
+      endcase
+    end
+
+    // The parallel prefix counter is of the structure of a Brent-Kung Adder. In the first
+    // log2(width) stages, the sum of the n preceding bit lines is computed for the bit lines at
+    // positions 2**n-1 (power-of-two positions) where n denotes the current stage.
+    // In stage n=log2(width), the count for position width-1 (the MSB) is finished.
+    // For the intermediate values, an inverse adder tree then computes the bit counts for the bit
+    // lines at positions
+    // m = 2**(n-1) + i*2**(n-2), where i = [1 ... width / 2**(n-1)-1] and n = [log2(width) ... 2].
+    // Thus, at every subsequent stage the result of two previously unconnected sub-trees is
+    // summed, starting at the node summing bits [width/2-1 : 0] and [3*width/4-1: width/2]
+    // and moving to iteratively sum up all the sub-trees.
+    // The inverse adder tree thus features log2(width) - 1 stages the first of these stages is a
+    // single addition at position 3*width/4 - 1. It does not interfere with the last
+    // stage of the primary adder tree. These stages can thus be folded together, resulting in a
+    // total of 2*log2(width)-2 stages.
+    // For more details refer to R. Brent, H. T. Kung, "A Regular Layout for Parallel Adders",
+    // (1982).
+    // For a bitline at position p, only bits
+    // bitcnt_partial[max(i, such that p % log2(i) == 0)-1 : 0] are needed for generation of the
+    // butterfly network control signals. The adders in the intermediate value adder tree thus need
+    // not be full 5-bit adders. We leave the optimization to the synthesis tools.
+    //
+    // Consider the following 8-bit example for illustraton.
+    //
+    // let bitcnt_bits = 8'babcdefgh.
+    //
+    //                   a  b  c  d  e  f  g  h
+    //                   | /:  | /:  | /:  | /:
+    //                   |/ :  |/ :  |/ :  |/ :
+    // stage 1:          +  :  +  :  +  :  +  :
+    //                   |  : /:  :  |  : /:  :
+    //                   |,--+ :  :  |,--+ :  :
+    // stage 2:          +  :  :  :  +  :  :  :
+    //                   |  :  |  : /:  :  :  :
+    //                   |,-----,--+ :  :  :  : ^-primary adder tree
+    // stage 3:          +  :  +  :  :  :  :  : -------------------------
+    //                   :  | /| /| /| /| /|  : ,-intermediate adder tree
+    //                   :  |/ |/ |/ |/ |/ :  :
+    // stage 4           :  +  +  +  +  +  :  :
+    //                   :  :  :  :  :  :  :  :
+    // bitcnt_partial[i] 7  6  5  4  3  2  1  0
+
+    always_comb begin
+      bitcnt_partial = '{default: '0};
+      // stage 1
+      for (int unsigned i=1; i<32; i+=2) begin
+        bitcnt_partial[i] = {5'h0, bitcnt_bits[i]} + {5'h0, bitcnt_bits[i-1]};
+      end
+      // stage 2
+      for (int unsigned i=3; i<32; i+=4) begin
+        bitcnt_partial[i] = bitcnt_partial[i-2] + bitcnt_partial[i];
+      end
+      // stage 3
+      for (int unsigned i=7; i<32; i+=8) begin
+        bitcnt_partial[i] = bitcnt_partial[i-4] + bitcnt_partial[i];
+      end
+      // stage 4
+      for (int unsigned i=15; i <32; i+=16) begin
+        bitcnt_partial[i] = bitcnt_partial[i-8] + bitcnt_partial[i];
+      end
+      // stage 5
+      bitcnt_partial[31] = bitcnt_partial[15] + bitcnt_partial[31];
+      // ^- primary adder tree
+      // -------------------------------
+      // ,-intermediate value adder tree
+      bitcnt_partial[23] = bitcnt_partial[15] + bitcnt_partial[23];
+
+      // stage 6
+      for (int unsigned i=11; i<32; i+=8) begin
+        bitcnt_partial[i] = bitcnt_partial[i-4] + bitcnt_partial[i];
+      end
+
+      // stage 7
+      for (int unsigned i=5; i<32; i+=4) begin
+        bitcnt_partial[i] = bitcnt_partial[i-2] + bitcnt_partial[i];
+      end
+      // stage 8
+      bitcnt_partial[0] = {5'h0, bitcnt_bits[0]};
+      for (int unsigned i=2; i<32; i+=2) begin
+        bitcnt_partial[i] = bitcnt_partial[i-1] + {5'h0, bitcnt_bits[i]};
+      end
+    end
+
+    ///////////////
+    // Butterfly //
+    ///////////////
+
+    // The butterfly / inverse butterfly network is shared between bext/bdep (zbe)instructions
+    // respectively and grev / gorc instructions (zbp).
+    // For bdep, the control bits mask of a local left region is generated by
+    // the inverse of a n-bit left rotate and complement upon wrap (LROTC) operation by the number
+    // of ones in the deposit bitmask to the right of the segment. n hereby denotes the width
+    // of the according segment. The bitmask for a pertaining local right region is equal to the
+    // corresponding local left region. Bext uses an analogue inverse process.
+    // Consider the following 8-bit example.  For details, see Hilewitz et al. "Fast Bit Gather,
+    // Bit Scatter and Bit Permuation Instructions for Commodity Microprocessors", (2008).
+
+    // 8-bit example:  (Hilewitz et al.)
+    // Consider the instruction bdep operand_a_i deposit_mask
+    // Let operand_a_i = 8'babcd_efgh
+    //    deposit_mask = 8'b1010_1101
+    //
+    // control bitmask for stage 1:
+    //  - number of ones in the right half of the deposit bitmask: 3
+    //  - width of the segment: 4
+    //  - control bitmask = ~LROTC(4'b0, 3)[3:0] = 4'b1000
+    //
+    // control bitmask:   c3 c2  c1 c0  c3 c2  c1 c0
+    //                    1  0   0  0   1  0   0  0
+    //                    <- L ----->   <- R ----->
+    // operand_a_i        a  b   c  d   e  f   g  h
+    //                    :\ |   |  |  /:  |   |  |
+    //                    : +|---|--|-+ :  |   |  |
+    //                    :/ |   |  |  \:  |   |  |
+    // stage 1            e  b   c  d   a  f   g  h
+    //                    <L->   <R->   <L->   <R->
+    // control bitmask:   c3 c2  c3 c2  c1 c0  c1 c0
+    //                    1  1   1  1   1  0   1  0
+    //                    :\ :\ /: /:   :\ |  /:  |
+    //                    : +:-+-:+ :   : +|-+ :  |
+    //                    :/ :/ \: \:   :/ |  \:  |
+    // stage 2            c  d   e  b   g  f   a  h
+    //                    L  R   L  R   L  R   L  R
+    // control bitmask:   c3 c3  c2 c2  c1 c1  c0 c0
+    //                    1  1   0  0   1  1   0  0
+    //                    :\/:   |  |   :\/:   |  |
+    //                    :  :   |  |   :  :   |  |
+    //                    :/\:   |  |   :/\:   |  |
+    // stage 3            d  c   e  b   f  g   a  h
+    // & deposit bitmask: 1  0   1  0   1  1   0  1
+    // result:            d  0   e  0   f  g   0  h
+
+    assign zbe_op = (operator_i == ALU_BEXT) | (operator_i == ALU_BDEP);
+
+    logic [31:0] butterfly_mask_l[5];
+    logic [31:0] butterfly_mask_r[5];
+    logic [31:0] butterfly_mask_not[5];
+    logic [31:0] lrotc_stage [5]; // left rotate and complement upon wrap
+
+    // bext / bdep
+    logic [31:0] butterfly_zbe_mask_l[5];
+    logic [31:0] butterfly_zbe_mask_r[5];
+    logic [31:0] butterfly_zbe_mask_not[5];
+
+    // grev / gorc
+    logic [31:0] butterfly_zbp_mask_l[5];
+    logic [31:0] butterfly_zbp_mask_r[5];
+    logic [31:0] butterfly_zbp_mask_not[5];
+
+    logic grev_op;
+    logic gorc_op;
+    logic zbp_op;
+
+    // number of bits in local r = 32 / 2**(stage + 1) = 16/2**stage
+    `define _N(stg) (16 >> stg)
+
+    // bext / bdep control bit generation
+    for (genvar stg=0; stg<5; stg++) begin
+      // number of segs: 2** stg
+      for (genvar seg=0; seg<2**stg; seg++) begin
+
+        assign lrotc_stage[stg][2*`_N(stg)*(seg+1)-1 : 2*`_N(stg)*seg] =
+            {{`_N(stg){1'b0}},{`_N(stg){1'b1}}} <<
+                bitcnt_partial[`_N(stg)*(2*seg+1)-1][$clog2(`_N(stg)):0];
+
+        assign butterfly_zbe_mask_l[stg][`_N(stg)*(2*seg+2)-1 : `_N(stg)*(2*seg+1)]
+                     = ~lrotc_stage[stg][`_N(stg)*(2*seg+2)-1 : `_N(stg)*(2*seg+1)];
+
+        assign butterfly_zbe_mask_r[stg][`_N(stg)*(2*seg+1)-1 : `_N(stg)*(2*seg)]
+                     = ~lrotc_stage[stg][`_N(stg)*(2*seg+2)-1 : `_N(stg)*(2*seg+1)];
+
+        assign butterfly_zbe_mask_l[stg][`_N(stg)*(2*seg+1)-1 : `_N(stg)*(2*seg)]   = '0;
+        assign butterfly_zbe_mask_r[stg][`_N(stg)*(2*seg+2)-1 : `_N(stg)*(2*seg+1)] = '0;
+      end
+    end
+    `undef _N
+
+    for (genvar stg=0; stg<5; stg++) begin
+      assign butterfly_zbe_mask_not[stg] =
+          ~(butterfly_zbe_mask_l[stg] | butterfly_zbe_mask_r[stg]);
+    end
+
+    // grev / gorc control bit generation
+    assign butterfly_zbp_mask_l[0] = shift_amt[4] ? 32'hffff_0000 : 32'h0000_0000;
+    assign butterfly_zbp_mask_r[0] = shift_amt[4] ? 32'h0000_ffff : 32'h0000_0000;
+    assign butterfly_zbp_mask_not[0] =
+       !shift_amt[4] || (shift_amt[4] && gorc_op) ? 32'hffff_ffff : 32'h0000_0000;
+
+    assign butterfly_zbp_mask_l[1] = shift_amt[3] ? 32'hff00_ff00 : 32'h0000_0000;
+    assign butterfly_zbp_mask_r[1] = shift_amt[3] ? 32'h00ff_00ff : 32'h0000_0000;
+    assign butterfly_zbp_mask_not[1] =
+       !shift_amt[3] || (shift_amt[3] && gorc_op) ? 32'hffff_ffff : 32'h0000_0000;
+
+    assign butterfly_zbp_mask_l[2] = shift_amt[2] ? 32'hf0f0_f0f0 : 32'h0000_0000;
+    assign butterfly_zbp_mask_r[2] = shift_amt[2] ? 32'h0f0f_0f0f : 32'h0000_0000;
+    assign butterfly_zbp_mask_not[2] =
+       !shift_amt[2] || (shift_amt[2] && gorc_op) ? 32'hffff_ffff : 32'h0000_0000;
+
+    assign butterfly_zbp_mask_l[3] = shift_amt[1] ? 32'hcccc_cccc : 32'h0000_0000;
+    assign butterfly_zbp_mask_r[3] = shift_amt[1] ? 32'h3333_3333 : 32'h0000_0000;
+    assign butterfly_zbp_mask_not[3] =
+       !shift_amt[1] || (shift_amt[1] && gorc_op) ? 32'hffff_ffff : 32'h0000_0000;
+
+    assign butterfly_zbp_mask_l[4] = shift_amt[0] ? 32'haaaa_aaaa : 32'h0000_0000;
+    assign butterfly_zbp_mask_r[4] = shift_amt[0] ? 32'h5555_5555 : 32'h0000_0000;
+    assign butterfly_zbp_mask_not[4] =
+       !shift_amt[0] || (shift_amt[0] && gorc_op) ? 32'hffff_ffff : 32'h0000_0000;
+
+    // grev / gorc instructions
+    assign grev_op = RV32B ? (operator_i == ALU_GREV) : 1'b0;
+    assign gorc_op = RV32B ? (operator_i == ALU_GORC) : 1'b0;
+    assign zbp_op = grev_op | gorc_op;
+
+    // select set of masks:
+    assign butterfly_mask_l   = zbp_op ? butterfly_zbp_mask_l   : butterfly_zbe_mask_l;
+    assign butterfly_mask_r   = zbp_op ? butterfly_zbp_mask_r   : butterfly_zbe_mask_r;
+    assign butterfly_mask_not = zbp_op ? butterfly_zbp_mask_not : butterfly_zbe_mask_not;
+
+    always_comb begin
+      butterfly_result = operand_a_i;
+
+      butterfly_result = butterfly_result & butterfly_mask_not[0] |
+          ((butterfly_result & butterfly_mask_l[0]) >> 16)|
+          ((butterfly_result & butterfly_mask_r[0]) << 16);
+
+      butterfly_result = butterfly_result & butterfly_mask_not[1] |
+          ((butterfly_result & butterfly_mask_l[1]) >> 8)|
+          ((butterfly_result & butterfly_mask_r[1]) << 8);
+
+      butterfly_result = butterfly_result & butterfly_mask_not[2] |
+          ((butterfly_result & butterfly_mask_l[2]) >> 4)|
+          ((butterfly_result & butterfly_mask_r[2]) << 4);
+
+      butterfly_result = butterfly_result & butterfly_mask_not[3] |
+          ((butterfly_result & butterfly_mask_l[3]) >> 2)|
+          ((butterfly_result & butterfly_mask_r[3]) << 2);
+
+      butterfly_result = butterfly_result & butterfly_mask_not[4] |
+          ((butterfly_result & butterfly_mask_l[4]) >> 1)|
+          ((butterfly_result & butterfly_mask_r[4]) << 1);
+
+      if (!zbp_op) begin
+        butterfly_result = butterfly_result & operand_b_i;
+      end
+    end
+
+    always_comb begin
+      invbutterfly_result = operand_a_i & operand_b_i;
+
+      invbutterfly_result = invbutterfly_result & butterfly_mask_not[4] |
+          ((invbutterfly_result & butterfly_mask_l[4]) >> 1)|
+          ((invbutterfly_result & butterfly_mask_r[4]) << 1);
+
+      invbutterfly_result = invbutterfly_result & butterfly_mask_not[3] |
+          ((invbutterfly_result & butterfly_mask_l[3]) >> 2)|
+          ((invbutterfly_result & butterfly_mask_r[3]) << 2);
+
+      invbutterfly_result = invbutterfly_result & butterfly_mask_not[2] |
+          ((invbutterfly_result & butterfly_mask_l[2]) >> 4)|
+          ((invbutterfly_result & butterfly_mask_r[2]) << 4);
+
+      invbutterfly_result = invbutterfly_result & butterfly_mask_not[1] |
+          ((invbutterfly_result & butterfly_mask_l[1]) >> 8)|
+          ((invbutterfly_result & butterfly_mask_r[1]) << 8);
+
+      invbutterfly_result = invbutterfly_result & butterfly_mask_not[0] |
+          ((invbutterfly_result & butterfly_mask_l[0]) >> 16)|
+          ((invbutterfly_result & butterfly_mask_r[0]) << 16);
+    end
+
     /////////////////////////
     // Shuffle / Unshuffle //
     /////////////////////////
@@ -429,8 +742,8 @@ module ibex_alu #(
 
       if (shuffle_flip) begin
         shuffle_result = (shuffle_result & 32'h8822_4411) |
-            ((shuffle_result << 6) &  FLIP_MASK_L[0])  | ((shuffle_result >> 6) & FLIP_MASK_R[0]) |
-            ((shuffle_result << 9) &  FLIP_MASK_L[1])  | ((shuffle_result >> 9) & FLIP_MASK_R[1]) |
+            ((shuffle_result << 6)  & FLIP_MASK_L[0]) | ((shuffle_result >> 6)  & FLIP_MASK_R[0]) |
+            ((shuffle_result << 9)  & FLIP_MASK_L[1]) | ((shuffle_result >> 9)  & FLIP_MASK_R[1]) |
             ((shuffle_result << 15) & FLIP_MASK_L[2]) | ((shuffle_result >> 15) & FLIP_MASK_R[2]) |
             ((shuffle_result << 21) & FLIP_MASK_L[3]) | ((shuffle_result >> 21) & FLIP_MASK_R[3]);
       end
@@ -458,21 +771,189 @@ module ibex_alu #(
 
       if (shuffle_flip) begin
         shuffle_result = (shuffle_result & 32'h8822_4411) |
-            ((shuffle_result << 6) &  FLIP_MASK_L[0])  | ((shuffle_result >> 6) & FLIP_MASK_R[0]) |
-            ((shuffle_result << 9) &  FLIP_MASK_L[1])  | ((shuffle_result >> 9) & FLIP_MASK_R[1]) |
+            ((shuffle_result << 6)  & FLIP_MASK_L[0]) | ((shuffle_result >> 6) & FLIP_MASK_R[0])  |
+            ((shuffle_result << 9)  & FLIP_MASK_L[1]) | ((shuffle_result >> 9) & FLIP_MASK_R[1])  |
             ((shuffle_result << 15) & FLIP_MASK_L[2]) | ((shuffle_result >> 15) & FLIP_MASK_R[2]) |
             ((shuffle_result << 21) & FLIP_MASK_L[3]) | ((shuffle_result >> 21) & FLIP_MASK_R[3]);
       end
 
     end
+    ///////////////////////////////////////////////////
+    // Carry-less Multiply + Cyclic Redundancy Check //
+    ///////////////////////////////////////////////////
+
+    // Carry-less multiplication can be understood as multiplication based on
+    // the addition interpreted as the bit-wise xor operation.
+    //
+    // Example: 1101 X 1011 = 1111111:
+    //
+    //       1011 X 1101
+    //       -----------
+    //              1101
+    //         xor 1101
+    //         ---------
+    //             10111
+    //        xor 0000
+    //        ----------
+    //            010111
+    //       xor 1101
+    //       -----------
+    //           1111111
+    //
+    // Architectural details:
+    //         A 32 x 32-bit array
+    //         [ operand_b[i] ? (operand_a << i) : '0 for i in 0 ... 31 ]
+    //         is generated. The entries of the array are pairwise 'xor-ed'
+    //         together in a 5-stage binary tree.
+    //
+    //
+    // Cyclic Redundancy Check:
+    //
+    // CRC-32 (CRC-32/ISO-HDLC) and CRC-32C (CRC-32/ISCSI) are directly implemented. For
+    // documentation of the crc configuration (crc-polynomials, initialization, reflection, etc.)
+    // see http://reveng.sourceforge.net/crc-catalogue/all.htm
+    // A useful guide to crc arithmetic and algorithms is given here:
+    // http://www.piclist.com/techref/method/math/crcguide.html.
+    //
+    // The CRC operation solves the following equation using binary polynomial arithmetic:
+    //
+    // rev(rd)(x) = rev(rs1)(x) * x**n mod {1, P}(x)
+    //
+    // where P denotes lower 32 bits of the corresponding CRC polynomial, rev(a) the bit reversal
+    // of a, n = 8,16, or 32 for .b, .h, .w -variants. {a, b} denotes bit concatenation.
+    //
+    // Using barret reduction, one can show that
+    //
+    // M(x) mod P(x) = R(x) =
+    //          (M(x) * x**n) & {deg(P(x)'{1'b1}}) ^ (M(x) x**-(deg(P(x) - n)) cx mu(x) cx P(x),
+    //
+    // Where mu(x) = polydiv(x**64, {1,P}) & 0xffffffff. Here, 'cx' refers to carry-less
+    // multiplication. Substituting rev(rd)(x) for R(x) and rev(rs1)(x) for M(x) and solving for
+    // rd(x) with P(x) a crc32 polynomial (deg(P(x)) = 32), we get
+    //
+    // rd = rev( (rev(rs1) << n)  ^ ((rev(rs1) >> (32-n)) cx mu cx P)
+    //    = (rs1 >> n) ^ rev(rev( (rs1 << (32-n)) cx rev(mu)) cx P)
+    //                       ^-- cycle 0--------------------^
+    //      ^- cycle 1 -------------------------------------------^
+    //
+    // In the last step we used the fact that carry-less multiplication is bit-order agnostic:
+    // rev(a cx b) = rev(a) cx rev(b).
+
+    logic clmul_rmode;
+    logic clmul_hmode;
+    logic [31:0] clmul_op_a;
+    logic [31:0] clmul_op_b;
+    logic [31:0] operand_b_rev;
+    logic [31:0] clmul_and_stage[32];
+    logic [31:0] clmul_xor_stage1[16];
+    logic [31:0] clmul_xor_stage2[8];
+    logic [31:0] clmul_xor_stage3[4];
+    logic [31:0] clmul_xor_stage4[2];
+
+    logic [31:0] clmul_result_raw;
+    logic [31:0] clmul_result_rev;
+
+    for (genvar i=0; i<32; i++) begin: gen_rev_operand_b
+      assign operand_b_rev[i] = operand_b_i[31-i];
+    end
+
+    assign clmul_rmode = operator_i == ALU_CLMULR;
+    assign clmul_hmode = operator_i == ALU_CLMULH;
+
+    // CRC
+    localparam logic [31:0] CRC32_POLYNOMIAL = 32'h04c1_1db7;
+    localparam logic [31:0] CRC32_MU_REV = 32'hf701_1641;
+
+    localparam logic [31:0] CRC32C_POLYNOMIAL = 32'h1edc_6f41;
+    localparam logic [31:0] CRC32C_MU_REV = 32'hdea7_13f1;
+
+    logic crc_op;
+    logic crc_hmode;
+    logic crc_bmode;
+
+    logic crc_cpoly;
+
+    logic [31:0] crc_operand;
+    logic [31:0] crc_poly;
+    logic [31:0] crc_mu_rev;
+
+    assign crc_op = (operator_i == ALU_CRC32C_W) | (operator_i == ALU_CRC32_W) |
+                    (operator_i == ALU_CRC32C_H) | (operator_i == ALU_CRC32_H) |
+                    (operator_i == ALU_CRC32C_B) | (operator_i == ALU_CRC32_B);
+
+    assign crc_cpoly = (operator_i == ALU_CRC32C_W) |
+                       (operator_i == ALU_CRC32C_H) |
+                       (operator_i == ALU_CRC32C_B);
+
+    assign crc_hmode = (operator_i == ALU_CRC32_H) | (operator_i == ALU_CRC32C_H);
+    assign crc_bmode = (operator_i == ALU_CRC32_B) | (operator_i == ALU_CRC32C_B);
+
+    assign crc_poly   = crc_cpoly ? CRC32C_POLYNOMIAL : CRC32_POLYNOMIAL;
+    assign crc_mu_rev = crc_cpoly ? CRC32C_MU_REV : CRC32_MU_REV;
+
+    always_comb begin
+      unique case(1'b1)
+        crc_bmode: crc_operand = {operand_a_i[7:0], 24'h0};
+        crc_hmode: crc_operand = {operand_a_i[15:0], 16'h0};
+        default:   crc_operand = operand_a_i;
+      endcase
+    end
+
+    // Select clmul input
+    always_comb begin
+      if (crc_op) begin
+        clmul_op_a = instr_first_cycle_i ? crc_operand : imd_val_q_i;
+        clmul_op_b = instr_first_cycle_i ? crc_mu_rev : crc_poly;
+      end else begin
+        clmul_op_a = clmul_rmode | clmul_hmode ? operand_a_rev : operand_a_i;
+        clmul_op_b = clmul_rmode | clmul_hmode ? operand_b_rev : operand_b_i;
+      end
+    end
+
+    for (genvar i=0; i<32; i++) begin : gen_clmul_and_op
+      assign clmul_and_stage[i] = clmul_op_b[i] ? clmul_op_a << i : '0;
+    end
+
+    for (genvar i=0; i<16; i++) begin : gen_clmul_xor_op_l1
+      assign clmul_xor_stage1[i] = clmul_and_stage[2*i] ^ clmul_and_stage[2*i+1];
+    end
+
+    for (genvar i=0; i<8; i++) begin : gen_clmul_xor_op_l2
+      assign clmul_xor_stage2[i] = clmul_xor_stage1[2*i] ^ clmul_xor_stage1[2*i+1];
+    end
+
+    for (genvar i=0; i<4; i++) begin : gen_clmul_xor_op_l3
+      assign clmul_xor_stage3[i] = clmul_xor_stage2[2*i] ^ clmul_xor_stage2[2*i+1];
+    end
+
+    for (genvar i=0; i<2; i++) begin : gen_clmul_xor_op_l4
+      assign clmul_xor_stage4[i] = clmul_xor_stage3[2*i] ^ clmul_xor_stage3[2*i+1];
+    end
+
+    assign clmul_result_raw = clmul_xor_stage4[0] ^ clmul_xor_stage4[1];
+
+    for (genvar i=0; i<32; i++) begin : gen_rev_clmul_result
+      assign clmul_result_rev[i] = clmul_result_raw[31-i];
+    end
+
+    // clmulr_result = rev(clmul(rev(a), rev(b)))
+    // clmulh_result = clmulr_result >> 1
+    always_comb begin
+      case(1'b1)
+        clmul_rmode: clmul_result = clmul_result_rev;
+        clmul_hmode: clmul_result = {1'b0, clmul_result_rev[31:1]};
+        default:     clmul_result = clmul_result_raw;
+      endcase
+    end
 
     //////////////////////////////////////
     // Multicycle Bitmanip Instructions //
     //////////////////////////////////////
-    // Ternary instructions + Shift Rotations
+    // Ternary instructions + Shift Rotations + CRC
     // For ternary instructions (zbt), operand_a_i is tied to rs1 in the first cycle and rs3 in the
     // second cycle. operand_b_i is always tied to rs2.
 
+
     always_comb begin
       unique case (operator_i)
         ALU_CMOV: begin
@@ -509,6 +990,23 @@ module ibex_alu #(
             imd_val_we_o = 1'b0;
           end
         end
+
+        ALU_CRC32_W, ALU_CRC32C_W,
+        ALU_CRC32_H, ALU_CRC32C_H,
+        ALU_CRC32_B, ALU_CRC32C_B: begin
+          imd_val_d_o = clmul_result_rev;
+          unique case(1'b1)
+            crc_bmode: multicycle_result = clmul_result_rev ^ (operand_a_i >> 8);
+            crc_hmode: multicycle_result = clmul_result_rev ^ (operand_a_i >> 16);
+            default:   multicycle_result = clmul_result_rev;
+          endcase
+          if (instr_first_cycle_i) begin
+            imd_val_we_o = 1'b1;
+          end else begin
+            imd_val_we_o = 1'b0;
+          end
+        end
+
         default: begin
           imd_val_d_o = operand_a_i;
           imd_val_we_o = 1'b0;
@@ -534,33 +1032,8 @@ module ibex_alu #(
     // Min / Max //
     ///////////////
 
-    assign minmax_result = (cmp_result ? operand_a_i : operand_b_i);
+    assign minmax_result = cmp_result ? operand_a_i : operand_b_i;
 
-    /////////////////
-    // Bitcounting //
-    /////////////////
-
-    logic        bitcnt_ctz;
-    logic        bitcnt_pcnt;
-    logic [31:0] bitcnt_bits;
-    logic [32:0] bitcnt_bit_enable;
-
-    assign bitcnt_ctz  = (operator_i == ALU_CTZ);
-    assign bitcnt_pcnt = (operator_i == ALU_PCNT);
-
-    assign bitcnt_bits = bitcnt_pcnt ? operand_a_i : (bitcnt_ctz ? ~operand_a_i : ~operand_a_rev);
-
-    always_comb begin
-      bitcnt_result = '0;
-      bitcnt_bit_enable = {32'b0, 1'b1}; // bit 32 unused.
-      for (int unsigned i=0; i<32; i++) begin : gen_bitcnt_adder
-        // keep counting if all previous bits are 1
-        bitcnt_bit_enable[i+1] = bitcnt_pcnt || (bitcnt_bit_enable[i] && bitcnt_bits[i]);
-        if (bitcnt_bit_enable[i]) begin
-          bitcnt_result[5:0] = bitcnt_result[5:0] + {5'h0, bitcnt_bits[i]};
-        end
-      end
-    end
 
     //////////
     // Pack //
@@ -568,8 +1041,8 @@ module ibex_alu #(
 
     logic packu;
     logic packh;
-    assign packu = (operator_i == ALU_PACKU);
-    assign packh = (operator_i == ALU_PACKH);
+    assign packu = operator_i == ALU_PACKU;
+    assign packh = operator_i == ALU_PACKH;
 
     always_comb begin
       unique case (1'b1)
@@ -578,17 +1051,29 @@ module ibex_alu #(
         default: pack_result = {operand_b_i[15:0], operand_a_i[15:0]};
       endcase
     end
+
+    //////////
+    // Sext //
+    //////////
+
+    assign sext_result = (operator_i == ALU_SEXTB) ?
+        { {24{operand_a_i[7]}}, operand_a_i[7:0]} : { {16{operand_a_i[15]}}, operand_a_i[15:0]};
+
   end else begin : g_no_alu_rvb
     // RV32B result signals
-    assign minmax_result     = '0;
-    assign bitcnt_result     = '0;
-    assign pack_result       = '0;
-    assign multicycle_result = '0;
-    assign singlebit_result  = '0;
-    assign shuffle_result    = '0;
+    assign minmax_result       = '0;
+    assign bitcnt_result       = '0;
+    assign pack_result         = '0;
+    assign sext_result         = '0;
+    assign multicycle_result   = '0;
+    assign singlebit_result    = '0;
+    assign shuffle_result      = '0;
+    assign butterfly_result    = '0;
+    assign invbutterfly_result = '0;
+    assign clmul_result        = '0;
     // RV32B support signals
-    assign imd_val_d_o  = '0;
-    assign imd_val_we_o = '0;
+    assign imd_val_d_o         = '0;
+    assign imd_val_we_o        = '0;
   end
 
   ////////////////
@@ -599,7 +1084,7 @@ module ibex_alu #(
     result_o   = '0;
 
     unique case (operator_i)
-      // Bitwise Logic Operations (negate: RV32B Ops)
+      // Bitwise Logic Operations (negate: RV32B)
       ALU_XOR,  ALU_XNOR,
       ALU_OR,   ALU_ORN,
       ALU_AND,  ALU_ANDN: result_o = bwlogic_result;
@@ -610,11 +1095,10 @@ module ibex_alu #(
       // Shift Operations
       ALU_SLL,  ALU_SRL,
       ALU_SRA,
-      // RV32B Ops
-      ALU_SLO,  ALU_SRO,
-      ALU_GREV, ALU_GORC: result_o = shift_result;
+      // RV32B
+      ALU_SLO,  ALU_SRO: result_o = shift_result;
 
-      // Shuffle Operations (RV32B Ops)
+      // Shuffle Operations (RV32B)
       ALU_SHFL, ALU_UNSHFL: result_o = shuffle_result;
 
       // Comparison Operations
@@ -623,27 +1107,49 @@ module ibex_alu #(
       ALU_LT,   ALU_LTU,
       ALU_SLT,  ALU_SLTU: result_o = {31'h0,cmp_result};
 
-      // MinMax Operations (RV32B Ops)
+      // MinMax Operations (RV32B)
       ALU_MIN,  ALU_MAX,
       ALU_MINU, ALU_MAXU: result_o = minmax_result;
 
-      // Bitcount Operations (RV32B Ops)
+      // Bitcount Operations (RV32B)
       ALU_CLZ, ALU_CTZ,
       ALU_PCNT: result_o = {26'h0, bitcnt_result};
 
-      // Pack Operations (RV32B Ops)
+      // Pack Operations (RV32B)
       ALU_PACK, ALU_PACKH,
       ALU_PACKU: result_o = pack_result;
 
-      // Ternary Bitmanip Operations (RV32B Ops)
+      // Sign-Extend (RV32B)
+      ALU_SEXTB, ALU_SEXTH: result_o = sext_result;
+
+      // Ternary Bitmanip Operations (RV32B)
       ALU_CMIX, ALU_CMOV,
       ALU_FSL,  ALU_FSR,
-      ALU_ROL,  ALU_ROR: result_o = multicycle_result;
-
-      // Single-Bit Bitmanip Operations (RV32B Ops)
+      // Rotate Shift (RV32B)
+      ALU_ROL, ALU_ROR,
+      // Cyclic Redundancy Checks (RV32B)
+      ALU_CRC32_W, ALU_CRC32C_W,
+      ALU_CRC32_H, ALU_CRC32C_H,
+      ALU_CRC32_B, ALU_CRC32C_B: result_o = multicycle_result;
+
+      // Single-Bit Bitmanip Operations (RV32B)
       ALU_SBSET, ALU_SBCLR,
       ALU_SBINV, ALU_SBEXT: result_o = singlebit_result;
 
+      // Bit Extract / Deposit (RV32B)
+      ALU_BDEP:  result_o = butterfly_result;
+      ALU_BEXT:  result_o = invbutterfly_result;
+
+      // General Reverse / Or-combine (RV32B)
+      ALU_GREV, ALU_GORC: result_o = butterfly_result;
+
+      // Bit Field Place (RV32B)
+      ALU_BFP: result_o = bfp_result;
+
+      // Carry-less Multiply Operations (RV32B)
+      ALU_CLMUL, ALU_CLMULR,
+      ALU_CLMULH: result_o = clmul_result;
+
       default: ;
     endcase
   end