fc0f4bc41408502fbc03b0511b35405efb064bc6
axi_ad9361: Delete the old sync generator from the core
diff --git a/library/common/ad_tdd_sync.v b/library/common/ad_tdd_sync.v
index f60a39b2..c24301e6 100644
--- a/library/common/ad_tdd_sync.v
+++ b/library/common/ad_tdd_sync.v
@@ -40,83 +40,55 @@
 
 module ad_tdd_sync (
 
-  clk,                                          // system clock (100 Mhz)
-  rst,
+  clk,                                           // system clock (100 Mhz)
+  rstn,
 
-  sync_en,                                      // synchronization enabled
-
-  enable_in,                                    // tdd enable signal asserted by software
-  enable_out,                                   // synchronized tdd_enable
-
-  sync                                          // re-synchronization signal
+  sync                                           // re-synchronization signal
 );
 
-  parameter       TDD_SYNC_PERIOD = 100000000;  // 1 second
+  localparam      PULSE_CNTR_WIDTH  = 7;
+  parameter       TDD_SYNC_PERIOD   = 100000000; // t_period * clk_freq - 1
 
   input           clk;
-  input           rst;
-  input           sync_en;
-  input           enable_in;
-  output          enable_out;
+  input           rstn;
   output          sync;
 
   // internal registers
 
-  reg             sync = 1'b0;
-  reg             enable_out = 1'b0;
-  reg             enable_synced = 1'b0;
-  reg     [ 2:0]  pulse_counter = 3'h7;
-  reg     [31:0]  sync_counter = 32'h0;
-  reg             sync_pulse = 1'b0;
-  reg             sync_period_eof = 1'b0;
+  reg     [(PULSE_CNTR_WIDTH-1):0]  pulse_counter   =  {PULSE_CNTR_WIDTH{1'b1}};
+  reg     [31:0]                    sync_counter    = 32'h0;
+  reg                               sync_pulse      =  1'b0;
+  reg                               sync_period_eof =  1'b0;
 
-  // the sync module can be bypassed
-
-  always @(posedge clk) begin
-    if (rst == 1) begin
-      enable_out <= 1'b0;
-    end else begin
-      enable_out <= (sync_en) ? enable_synced : enable_in;
-      sync <= (sync_en) ? sync_pulse : 1'b0;
-    end
-  end
+  assign sync = sync_pulse;
 
   // a free running sync pulse generator
 
   always @(posedge clk) begin
-    if (rst == 1) begin
+    if (rstn == 1'b0) begin
       sync_counter <= 32'h0;
       sync_period_eof <= 1'b0;
     end else begin
       sync_counter <= (sync_counter < TDD_SYNC_PERIOD) ? (sync_counter + 1) : 32'b0;
-      sync_period_eof <= (sync_counter == TDD_SYNC_PERIOD) ? 1'b1 : 1'b0;
+      sync_period_eof <= (sync_counter == (TDD_SYNC_PERIOD - 1)) ? 1'b1 : 1'b0;
     end
   end
 
   // generate pulse with a specified width
 
   always @(posedge clk) begin
-    if (rst == 1) begin
+    if (rstn == 1'b0) begin
       pulse_counter <= 0;
       sync_pulse <= 0;
     end else begin
       pulse_counter <= (sync_pulse == 1'b1) ? pulse_counter + 1 : 3'h0;
       if(sync_period_eof == 1'b1) begin
         sync_pulse <= 1'b1;
-      end else if(pulse_counter == 3'h7) begin
+      end else if(pulse_counter == {PULSE_CNTR_WIDTH{1'b1}}) begin
         sync_pulse <= 1'b0;
       end
     end
   end
 
-  // syncronize tdd_enalbe generated by software
-
-  always @(posedge clk) begin
-    if (rst == 1'b1) begin
-      enable_synced <= 1'b0;
-    end else if (sync_period_eof == 1'b1) begin
-      enable_synced <= enable_in;
-    end
-  end
-
 endmodule
+